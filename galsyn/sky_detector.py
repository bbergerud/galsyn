import json
from copulas.multivariate.base import Multivariate
import torch
from pathlib import Path
from typing import Dict, Iterable, Optional, Tuple, Union
from .utils import *

class SkyDetectorGenerator(BaseGenerator):
    """
    Class associated with generating synthetic sky and detector noise.

    Attributes
    ----------
    dark_variance_column : str
        The name of the column associated with the dark variance.

    data : DataFrame
        When the `generate` method is executed, the generated synthetic
        sample is stored as this attribute.

    device : torch.device
        The device to generate the data on.

    dictionary : Dict
        A dictionary containing any parameters that are held constant.
        The key should be the parameter name, and if the parameter is
        filter dependent then the value should be another dictionary
        with the filter name as the key. Parameters that vary are
        generated by `generator`.

    generator : GaussianMultivariate
        A Gaussian Multivariate copula for generating sythetic data. Any
        parameters needed, but not part of this copula, should be stored
        as constants in the attribute `dictionary`.

    flux_per_count_column : str
        The name of the column associated with the flux/count ratio.

    gain_column : str
        The name of the column associated with the gain.

    sky_column : str
        The name of the column associated with the sky background flux.

    perturbation : callable, optional
        A function that modifies the base sky level. It should take as
        input a map of the average sky background level and return
        a modulated image.

    Methods
    -------
    __call__
        Returns a dictionary containing the images for each filter band.
        The key of the dictionary is the name of the filter band, while
        the values are the Tensors for each instance.

    __len__
        Returns the number of instances in `self.sample`

    noise_level
        Returns the background level in the indicated filter band,
        which is calculated as
            err (counts) = sqrt( (flux_counts + sky_counts) / gain + darkVariance)
        Note that any perturbations are not considered.

    sample
        Generates synthetic data from the copula and stores the result
        in `self.sample`.

    Examples
    --------
    import matplotlib.pyplot as plt
    import torch
    from galsyn.sky_detector import SkyDetectorGenerator
    from galsyn.random import perlin2d
    from galkit.functional import rescale

    def transform(image):
        return rescale(image, 0.5, 1.5)

    def perturbation(image):
        return image * perlin2d(
            shape = image.shape[-2:],
            resolution = (0.2, 0.2),
            transform = transform
        )

    sky = SkyDetectorGenerator(perturbation=perturbation)
    output = sky(
        sample_size=3,
        shape=(128,128),
        filter_bands='irg',
        output_counts=True,
        apply_noise=True,
        zero_mean=False
    )

    def foo(i, filter='r'):
        img = output[filter][i]
        fig, ax = plt.subplots()
        c = ax.imshow(img.squeeze())
        fig.colorbar(c, ax=ax)
        fig.show()

    for i,_ in enumerate(output['r']):
        foo(i)
    """
    def __init__(self,
        generator             : Multivariate = load_local_generator('field_generator_sdss.pkl'),
        dictionary_file       : str = local_file('field_dictionary_sdss.json'),
        dark_variance_column  : str = 'darkVariance',
        flux_per_count_column : str = 'nMgyPerCount',
        sky_column            : str = 'sky',
        gain_column           : str = 'gain',
        device                : Optional[torch.device] = None,
        perturbation          : Optional[callable] = None
    ):
        """
        Parameters
        ----------
        generator : Multivariate
            A Multivariate copula generator.

        dictionary_file : str
            The path location to a stored .json file, which contains some
            parameter values that are held constant.

        dark_variance_column : str
            The name of the column associated with the dark variance, which combines
            the read noise and dark current. Default is "darkVariance".

        flux_per_count_column : str
            The name of the column associated with the flux/count ratio.
            Default is "nMgyPerCount"

        sky_column : str
            The name of the column associated with the sky background flux,
            which is assumed to be in flux/arcsecondÂ². Default is "sky"

        gain_column : str
            The name of the column associated with the gain. Default is "gain".

        device : torch.device
            The device to generate the data on.

        perturbation : callable
            A function that can be used to modified the sky background level.
            Useful for applying procedural noise to the image.
        """
        self.generator  = generator
        self.dictionary = json.loads(Path(dictionary_file).read_text())
        self.dark_variance_column = dark_variance_column
        self.flux_per_count_column = flux_per_count_column
        self.sky_column = sky_column
        self.gain_column = gain_column
        self.device = device
        self.perturbation = perturbation

    def __call__(self,
        shape         : Tuple[int,int],
        apply_noise   : bool = True,
        filter_bands  : Iterable = 'ugriz',
        output_counts : bool=True,
        plate_scale   : Union[float, torch.Tensor] = 0.396,
        sample_size   : Optional[int] = None,
        zero_mean     : bool = True,
    ) -> Dict[str, torch.Tensor]:
        """
        Returns a dictionary containing the images for each filter band.
        The key of the dictionary is the name of the filter band, while
        the values are the Tensors for each instance.
        
        Parameters
        ----------
        shape : Tuple[int, int]
            The height and width of the image

        apply_noise : bool
            Boolean indicating whether to apply Poisson noise to the image.
            Default is True.

        filter_bands : Iterable
            The filter bands to generate data for.

        output_counts : bool
            Boolean indicating to output the flux in units of counts.
            Default is True.

        plate_scale : float, Tensor
            The plate scale of the image.

        sample_size : int, optional
            If passed, then `self.sample` is run with the `size=sample_size`

        zero_mean : bool
            Boolean indicating whether to subtract off the mean value from
            the image. Default is True.

        Returns
        -------
        output : Dict
            Dictionary whose keys are the filter band and the values are
            the image tensors.
        """
        if sample_size is not None:
            self.sample(sample_size)

        output = {}
        for k in filter_bands:
            ckeys = {
                'filter_band' : k,
                'dictionary'  : self.dictionary,
                'dataframe'   : self.data,
                'device'      : self.device,
                'view'        : (-1,1,1),
            }

            plate_scale = to_tensor(plate_scale, device=self.device, view=(-1,1,1))
            dark = accessor(self.dark_variance_column, **ckeys)
            gain = accessor(self.gain_column, **ckeys)
            fpc  = accessor(self.flux_per_count_column, **ckeys)
            sky  = accessor(self.sky_column, **ckeys) * plate_scale**2 / fpc

            # Sky has poisson noise in the photo-electrons rather than the counts
            sky = sky.mul(gain).expand(-1, *shape)
            if self.perturbation is not None:
                sky = torch.stack([self.perturbation(x) for x in sky])

            if apply_noise:
                noise = torch.poisson(dark.expand(-1,*shape)) + \
                        torch.poisson(sky).div(gain)
            else:
                noise = dark + sky.div(gain)

            if not output_counts:
                noise = noise * fpc
            
            if zero_mean:
                noise = noise - noise.mean(dim=(1,2), keepdim=True)
            
            output[k] = noise

        return output

    def noise_level(self,
        plate_scale   : float,
        filter_band   : str,
        output_counts : bool = True,
        index         : Optional[int] = None,        
        flux_counts   : Optional[torch.Tensor] = None,
    ) -> torch.Tensor:
        """
        Returns the noise level in the indicated filter band, which
        is calculated as

            err (counts) = sqrt( (flux_counts + sky_counts) / gain + dark_variance)      

        Parameters
        ----------
        plate_scale : float
            The plate scale of the image.

        filter_band : str
            The filter band to use when calculating the noise level.
        
        output_counts : bool
            Boolean indicating whether to output the flux in counts
            (True) or in the physical flux units (False). Default is
            True.

        index : int, optional
            Integer indicating the data sample to use. If set to `None`,
            then all the data samples are used.

        flux_counts : Tensor, optional
            A tensor representing the source flux counts.
        """
        ckeys = {
            'dataframe'   : self.data,
            'dictionary'  : self.dictionary,
            'filter_band' : filter_band,
            'index'       : index,
            'device'      : self.device,
            'view'        : (-1,1,1)
        }

        plate_scale = to_tensor(plate_scale, device=self.device, view=(-1,1,1))
        fpc  = accessor(self.flux_per_count_column, **ckeys)
        sky  = accessor(self.sky_column, **ckeys) * plate_scale**2 / fpc
        gain = accessor(self.gain_column, **ckeys)
        dark = accessor(self.dark_variance_column, **ckeys)

        if flux_counts is not None:
            sky = sky + flux_counts

        counts_err = torch.sqrt(sky / gain + dark)

        if output_counts:
            return counts_err
        else:
            return counts_err * fpc