from copulas.multivariate.base import Multivariate
import torch
from galkit.functional.magnitude import sdss_mag2flux
from galkit.spatial import coordinate, grid, resample
from typing import Dict, Iterable, Tuple
from .psf import DoubleGaussianPowerlawModel
from ..utils import *

class StarGenerator(BaseGenerator):
    """
    Class associated with generating synthetic foreground stars.

    Attributes
    ----------
    data : DataFrame
        When the sample method is executed, the generated synthetic
        data is stored as this attribute.

    device : torch.device
        The device to generate data on.

    magnitude_column : Text
        The name of the column associated with the total magnitude of the star.

    magnitude_to_flux : callable
        A function that converts the magnitude to flux.

    psf_model : callable
        The analytical psf model.

    Methods
    -------
    __call__
        Returns a dictionary containing the images for each filter band.
        The key of the dictionary is the name of the filter band, while
        the values are the Tensors for each instance.

    Examples
    --------
    import torch
    import matplotlib.pyplot as plt
    from galkit.functional.transform import fits2jpeg, arcsinh_stretch
    from galsyn.sky_detector import SkyDetectorGenerator
    from galsyn.star import StarGenerator, DoubleGaussianPowerlawModel

    sky  = SkyDetectorGenerator()
    star = StarGenerator(psf_model=DoubleGaussianPowerlawModel())

    sky.sample(2)

    kwargs = {
        'shape': (128,128),
        'filter_bands': 'irg',
        'output_counts': True,
        'apply_noise': True,
    }

    output_sky = sky(**kwargs)
    output_star = star(
        sky_detector=sky,
        output_star_s2n=True,
        output_star_mask=True,
        oversample=3,
        stars_per_pixel=0.002,
        **kwargs
    )

    imag = torch.stack([output_sky[k] + output_star['flux'][k] for k in 'irg'], dim=1)

    def foo(i):
        img1  = fits2jpeg(imag[i], desaturate=True)
        img2  = arcsinh_stretch(imag[i])
        fig, ax = plt.subplots(ncols=2, nrows=2)
        ax[0,0].imshow(img1.T)
        ax[0,0].set_title('fits2jpeg')
        ax[0,1].imshow(img2.T)
        ax[0,1].set_title('arcsinh_stretch')
        ax[1,0].imshow(output_star['s2n'][i].T)
        ax[1,0].set_title('Star S/N')
        ax[1,1].imshow(output_star['mask'][i].T)
        ax[1,1].set_title('Star Mask')
        fig.tight_layout()
        fig.show()

    for i in range(len(sky)):
        foo(i)
    """
    def __init__(self,
        generator         : Multivariate = load_local_generator('star_generator_sdss.pkl'),
        magnitude_column  : str = 'psfMag',
        magnitude_to_flux : callable = sdss_mag2flux,
        psf_model         : callable = DoubleGaussianPowerlawModel(),
        device            : Optional[torch.device] = None
    ):
        """
        Parameters
        ----------
        generator : Multivariate
            The path location to the file containing the GaussianMultivariate copula.

        magnitude_column : Text
            The name of the column associated with the total magnitude of the star.

        magnitude_to_flux : callable
            A function that converts the magnitude generated by the copula to flux.
            It should take as inputs the magnitude and filter band.

        psf_model : callable
            A function that returns the analytical PSF flux. It should take as input 
            the pixel offset (dx, dy), the total flux of the star (flux), the plate
            scale of the image, as well the sky-detector dictionary and dataframe
            parameters with the corresponding filter band, index, and device parameters.

        device : torch.device
            The device to generate the data on.
        """
        self.generator = generator
        self.magnitude_column  = magnitude_column
        self.magnitude_to_flux = magnitude_to_flux
        self.psf_model = psf_model
        self.device = device

    def sample(self, size:int) -> None:
        self.data = self.generator.sample(size)

    def __call__(self,
        shape            : Tuple[int,int],
        sky_detector     : BaseGenerator,
        apply_noise      : bool = True,
        filter_bands     : Iterable = 'ugriz',
        merge_masks      : bool = True,
        output_counts    : bool = True,
        output_star_mask : bool = False,
        output_star_s2n  : bool = False,
        oversample       : int = 1,
        plate_scale      : float = 0.396,
        stars_per_pixel  : float = 2e-4,
        s2n_mask_threshold : float = 1
    ) -> Dict:
        """
        Parameters
        ----------
        shape : Tuple[int,int]
            The image size

        sky_detector : BaseGenerator
            An instance of a sky-detector module.

        apply_noise : bool
            Boolean indicating whether to apply poisson noise to the outputs
            (True) or to return the analytical flux (False). Default is True.

        filter_bands : Iterable
            The filter bands to generate images for.
        
        merge_masks : bool
            Boolean indicating whether to merge the masks and/or S/N ratio
            across the different filter bands into a single value. It does
            this by taking the maximum value across the different filters.
            Default is True.

        output_counts : bool
            Boolean indicating to output the flux in units of counts.
            Default is True.

        output_star_mask : bool
            Boolean indicating whether to output a mask of the stars.
            Default is False. Note that the mask is constructed using
            the threshold parameter.

        output_star_s2n : bool
            Boolean indicating whether to output the ground truth 
            signal-to-noise map, which is calculated before any
            noise is added.

        oversample : int
            The oversampling factor. Useful for more accurately capturing the
            flux in the center when the brightness steeply falls off.

        plate_scale : float, Tensor
            The plate scale of the image in arcseconds / pixel.

        stars_per_pixel : float
            The average number of stars per pixel. The total number of stars
            is Poisson sampled based on the expectation value.

        s2n_mask_threshold : float
            The threshold for defining the mask, which corresponds to
                S/N > s2n_mask_threshold
            Only used if `output_star_mask=True`.

        Returns
        -------
        output : Dict
            Dictionary containing the collection of outputs. The keys are
            {'flux', 'mask', 's2n'} with the latter two occurring if the
            appropriate parameters are set to True.
        """
        cartesian = coordinate.cartesian(
            grid = grid.normalized_grid([x*oversample for x in shape], device=self.device),
            scale = max(shape),
            flip_lr = False,
            flip_ud = False
        )

        images = {k:[] for k in filter_bands}
        masks  = {k:[] for k in filter_bands}
        s2n    = {k:[] for k in filter_bands}

        for i in range(len(sky_detector)):
            n_stars = torch.tensor(shape[0] * shape[1] * stars_per_pixel)
            n_stars = int(torch.poisson(n_stars).item())

            if n_stars == 0:
                empty = torch.zeros((1,*shape), dtype=torch.float32, device=self.device)
                for k in filter_bands:
                    images[k].append(empty)
                    if output_star_mask:
                        masks[k].append(empty)
                    if output_star_s2n:
                        s2n[k].append(empty)
                continue

            # Random star positions (constant across filter bands)
            self.sample(n_stars)
            h0, w0 = torch.rand(2, n_stars, device=self.device)
            dx = (h0 * shape[0]).view(-1,1,1) - cartesian[0]
            dy = (w0 * shape[1]).view(-1,1,1) - cartesian[1]

            for k in filter_bands:
                sky_keys = {
                    'filter_band': k,
                    'dataframe'  : sky_detector.data,
                    'dictionary' : sky_detector.dictionary,
                    'index'      : i,
                    'device'     : self.device,
                }

                gain = accessor(sky_detector.gain_column, **sky_keys)
                fpc  = accessor(sky_detector.flux_per_count_column, **sky_keys)

                ckeys = {
                    'filter_band': k,
                    'dataframe': self.data,
                    'dictionary': {},
                    'device'     : self.device,
                }

                magnitude = accessor(self.magnitude_column, **ckeys)
                flux = self.magnitude_to_flux(magnitude, k).clip(0).div(fpc)
                flux = self.psf_model(dx, dy,
                    flux = flux,
                    plate_scale = plate_scale,
                    **sky_keys
                ).sum(dim=0, keepdims=True)

                if oversample > 1:
                    flux = resample.downscale_local_mean(flux, oversample)

                if output_star_s2n | output_star_mask:
                    noise = sky_detector.noise_level(
                        flux_counts = flux,
                        plate_scale = plate_scale,
                        filter_band = k,
                        output_counts = True,
                        index = i
                    )

                    if output_star_s2n:
                        s2n[k].append( flux / noise)

                    if output_star_mask:
                        if output_star_s2n:
                            masks[k].append(s2n[k][-1] > s2n_mask_threshold)
                        else:
                            masks[k].append(flux > s2n_mask_threshold * noise)

                if apply_noise:
                    flux = torch.poisson(flux * gain) / gain

                if not output_counts:
                    flux = flux * fpc

                images[k].append(flux)


        output = {'flux': {k:torch.cat(v, dim=0) for k,v in images.items()}}

        if output_star_mask:
            masks = {k:torch.cat(masks[k], dim=0) for k in filter_bands}
            if merge_masks:
                masks = torch.stack([masks[k] for k in filter_bands], dim=1)
                masks = torch.amax(masks, 1)
            output['mask'] = masks.float()

        if output_star_s2n:
            s2n = {k:torch.cat(s2n[k], dim=0) for k in filter_bands}
            if merge_masks:
                s2n = torch.stack([s2n[k] for k in filter_bands], dim=1)
                s2n = torch.amax(s2n,1)
            output['s2n'] = s2n             

        return output